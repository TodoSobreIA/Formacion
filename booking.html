<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Reserva de Cita</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 20px;
      text-align: center;
    }
    form {
      max-width: 400px;
      margin: auto;
      background: #f4f4f4;
      padding: 20px;
      border-radius: 8px;
    }
    label, select, input {
      display: block;
      width: 100%;
      margin: 10px 0;
    }
    button {
      background: #007bff;
      color: white;
      padding: 10px;
      border: none;
      cursor: pointer;
    }
    button:hover {
      background: #0056b3;
    }
    #message {
      margin-top: 15px;
      font-weight: bold;
    }
  </style>
</head>
<body>
  <h2>Reserva tu Cita</h2>
  <form id="bookingForm">
    <fieldset>
      <legend>Selecciona fecha y hora</legend>
      <label for="date">Elige una fecha:</label>
      <input type="date" id="date" name="date" required />
      
      <label for="time">Elige una hora:</label>
      <select id="time" name="time" required></select>
    </fieldset>
    <button type="submit">Reservar</button>
  </form>

  <p id="message" aria-live="polite"></p>

  <script>
    document.addEventListener("DOMContentLoaded", function () {
      const dateInput = document.getElementById("date");
      const timeSelect = document.getElementById("time");
      const messageBox = document.getElementById("message");

      // URL de tu Google Apps Script
      const scriptUrl = "https://script.google.com/macros/s/AKfycby6y4-eRWQLRQJZPXp8AjnEyz6h8Njt2L3GNe3kidQNbYncUZp8HDQuUv4epLIxjAzQaA/exec";

      // Configura la fecha mínima (mañana) para evitar que se seleccione el día actual
      function setMinDate() {
        const today = new Date();
        today.setDate(today.getDate() + 1);
        const minDate = today.toISOString().split("T")[0];
        dateInput.min = minDate;
        dateInput.value = minDate;
      }
      setMinDate();

      // Función auxiliar que suma 30 minutos a una hora (en formato "HH:MM")
      // Devuelve null si el resultado queda fuera del rango permitido (08:00 a 20:00)
      function addHalfHour(timeStr) {
        let [hour, minute] = timeStr.split(":").map(Number);
        minute += 30;
        if (minute === 60) {
          minute = 0;
          hour += 1;
        }
        if (hour > 20 || (hour === 20 && minute > 0)) {
          return null;
        }
        return `${String(hour).padStart(2, "0")}:${String(minute).padStart(2, "0")}`;
      }

      // Consulta las reservas para la fecha seleccionada (se asume que tu endpoint GET responde con JSON)
      async function fetchBookings(selectedDate) {
        try {
          const response = await fetch(`${scriptUrl}?action=getBookings&date=${selectedDate}`);
          if (!response.ok) {
            throw new Error("Error en la respuesta de red");
          }
          const data = await response.json();
          // Se asume que data.bookings es un arreglo con horas en formato "HH:MM"
          return data.bookings || [];
        } catch (error) {
          console.error("Error al obtener las reservas:", error);
          return [];
        }
      }

      // Actualiza las opciones de hora disponibles según las reservas obtenidas del servidor
      async function updateTimeOptions() {
        const selectedDate = dateInput.value;
        timeSelect.innerHTML = ""; // Limpiar el selector
        const blocked = new Set();

        const bookings = await fetchBookings(selectedDate);
        bookings.forEach((time) => {
          blocked.add(time);
          const nextTime = addHalfHour(time);
          if (nextTime) {
            blocked.add(nextTime);
          }
        });

        // Genera las ranuras de 08:00 a 20:00 en intervalos de 30 minutos
        for (let hour = 8; hour <= 20; hour++) {
          for (let min of ["00", "30"]) {
            const timeString = `${String(hour).padStart(2, "0")}:${min}`;
            if (!blocked.has(timeString)) {
              const option = document.createElement("option");
              option.value = timeString;
              option.textContent = timeString;
              timeSelect.appendChild(option);
            }
          }
        }
      }

      // Actualiza las opciones de hora cada vez que se cambia la fecha
      dateInput.addEventListener("change", updateTimeOptions);
      updateTimeOptions();

      // Maneja el envío del formulario para registrar una reserva
      document.getElementById("bookingForm").addEventListener("submit", async function (event) {
        event.preventDefault();

        const selectedDate = dateInput.value;
        const selectedTime = timeSelect.value;
        const selectedDateTime = `${selectedDate}T${selectedTime}`;

        try {
          // Se realiza la solicitud POST en modo "no-cors" para evitar errores de CORS.
          // La respuesta será opaca, por lo que se asume que la reserva fue exitosa.
          await fetch(scriptUrl, {
            method: "POST",
            mode: "no-cors", // Evita el error de CORS (respuesta opaca)
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ datetime: selectedDateTime, action: "book" })
          });
          messageBox.textContent = "Reserva enviada con éxito ✅";
          messageBox.style.color = "green";
          // Actualiza las opciones de hora tras la reserva
          await updateTimeOptions();
          setTimeout(() => { messageBox.textContent = ""; }, 3000);
        } catch (error) {
          console.error("Error al realizar la reserva:", error);
          messageBox.textContent = "Error al reservar ❌";
          messageBox.style.color = "red";
        }
      });
    });
  </script>
</body>
</html>
